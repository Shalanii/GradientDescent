%initialize data pointsx = [27.6252   -0.8369   -3.0496   55.6353    7.6559    6.1437    8.3983    4.3267   64.7878 50.5888   54.4505   40.9129    7.6602   26.3725   53.6989];y = [33.2399    3.8216    6.9667   58.7902   13.4380   11.4167    8.4626    5.3666   62.3270  56.4278   64.1532   42.0079    6.4660   28.7050   53.8727];%define initial m and c values randomlyc_i = randi(10);m_i = randi(10);%optimal m value - ideal_m and optimal c value - ideal_cideal_m = m_i;ideal_c = c_i;%define learning rateeata = 0.001;%define the size of mini batchbatch_size = 5;%size of the datasetN = size(x,2);%flag to stop the while loopstop = 0;#iteration countcount = 0;#arrays to store mini batch coordinatesx_batch = [];y_batch = [];while(stop==0)  count = count+1;    #generate the mini batch with random data points  for i=1:batch_size    n = randi(N);    x_batch(i)=x(n);    y_batch(i)=y(n);  endfor    der_c = find_derivative_of_rss_to_c(y_batch,x_batch,m_i,c_i,batch_size);  der_m = find_derivative_of_rss_to_m(y_batch,x_batch,m_i,c_i,batch_size);     %Stop criteria:   % if number of iterations>200, then the stip flag is set to true OR if the step size of either m or m (der_c or der_m) is less than 0.1, the stop condition is set to true.  if count>200 || (abs(der_c)<0.1 || (abs(der_m)<0.1 && count>2))    stop=1;    ideal_c = c_i;    ideal_m = m_i;  endif    c_i = c_i - (eata*der_c);  m_i = m_i - (eata*der_m);  c(end+1) = c_i;  m(end+1) = m_i;endZ = find_rss_for_m_c(y,m,x,c,N);contour(m,c,Z);%plot real data points and predicted straight linefigure();plot(x,y,'x');hold onpredicted = (x.*ideal_m) + ideal_c;plot(x,predicted,'-');%display optimal m and c valuesfprintf("Optimal m is : %d\nOptimal c is : %d\n",ideal_m,ideal_c);