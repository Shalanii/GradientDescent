%initialize data pointsx = [27.6252   -0.8369   -3.0496   55.6353    7.6559    6.1437    8.3983    4.3267   64.7878 50.5888   54.4505   40.9129    7.6602   26.3725   53.6989];y = [33.2399    3.8216    6.9667   58.7902   13.4380   11.4167    8.4626    5.3666   62.3270  56.4278   64.1532   42.0079    6.4660   28.7050   53.8727];%define initial m and c values randomlyc_i = 0;m_i = 0;%optimal m value - ideal_m and optimal c value - ideal_cideal_m = m_i;ideal_c = c_i;%define learning rateeata = 0.001;%initialize arrays to store m and c valuesc = [];m = [];%size of the datasetN = size(x,2);%flag to stop the while loopstop = 0;#iteration countcount = 0;while(stop==0)  count = count+1;  der_c = find_derivative_of_rss_to_c(y,x,m_i,c_i,N);  der_m = find_derivative_of_rss_to_m(y,x,m_i,c_i,N);   fprintf("der c = %d\tder_m = %d",der_c,der_m);      %Stop criteria:   % if number of iterations>200, then the stip flag is set to true OR if the step size of either m or m (der_c or der_m) is less than 0.1, the stop condition is set to true.  if count>20 || (abs(der_c)<0.1 || abs(der_m)<0.1)    stop=1;    ideal_c = c_i;    ideal_m = m_i;
  endif    %new m and c values are calculated and added to the arrays  c_i = c_i - (eata*der_c);  m_i = m_i - (eata*der_m);  c(end+1) = c_i;  m(end+1) = m_i; end%retrieve approximately 50 data points for M and C to plot the contourdiff_m = (max(m)-min(m))/50;diff_c = (max(c)-min(c))/50;M = [min(m):diff_m:max(m)];C = [min(c):diff_c:max(c)];%cacluate the cost for M and CZ = find_rss_for_m_c(y,m,x,c,N);%plotcontour(m,c,Z);hold on;plot(m,c,Z,'o');hold on;plot(ideal_m,ideal_c,'o');figure()Z2 = find_rss_for_m_c(y,M,x,C,N);surf(C,M,Z2);#figure()%plot(c,m,Z,'*');%plot real data points and predicted straight linefigure();plot(x,y,'x');hold onpredicted = (x.*ideal_m) + ideal_c;plot(x,predicted,'-');%display optimal m and c valuesfprintf("Optimal m is : %d\nOptimal c is : %d\n",ideal_m,ideal_c);